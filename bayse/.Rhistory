library(rstan)
x1=runif(100,0,30)
x2=runif(100,30,40)
y=10*x1-23*x2-15+rnorm(100,0,15)
pairs(data.frame(x1,x2,y))
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるが、可読性を高めるためちゃんとインデントしよう。
model <- "
data {
int N;
real X1[N];
vector[N] X2;
vector[N] Y;
}
parameters {
real a1;
real a2;
real b;
real<lower=0> sigma;
}
transformed parameters{
real mu[N]; //長さNの実数ベクトルを作る
for (i in 1:N)
mu[i] = a1*X1[i]+a2*X2[i]+b; //for文で、各データポイントに対して期待値muを作成
}
model {
for (i in 1:N)
Y[i] ~ normal(mu[i],sigma);
}"
yData<-list(N=length(y),X1=x1,X2=x2,Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
fit
fit
stan_hist(fit,pars=c("a1","a2","b"))
x1<-runif(100,0,30)
x2<-runif(100,30,40)
z<-0.3*x1-0.2*x2+1
p<-1/(1+exp(-z))
hist(p)
y<-c()
for (i in 1:100){
y[i]<-rbinom(1,1,p[i])} #Rにはベルヌーイ分布がないので、n=1の二項分布。
x1
x2
p
y
#演習：stanでロジスティック回帰モデルを作ってみよう。
#まずはデータ作成.yは確率p=sigmoid(a1x1+a2x2+b)で1,1-pで0となるようにする。
library(rstan)
x1<-runif(100,0,30)
x2<-runif(100,30,40)
z<-0.3*x1-0.2*x2+1
p<-1/(1+exp(-z))
hist(p)
y<-c()
for (i in 1:100){
y[i]<-rbinom(1,1,p[i])} #Rにはベルヌーイ分布がないので、n=1の二項分布。
#空欄を補ってStanコードを書いてみよう。
model <- "
data {
int N;
//Yの型に注意
}
parameters {
real a1;
real a2;
real b;
}
transformed parameters{
real p[N]; //長さNの実数ベクトルを作る
//hint:sigmoid関数はinv_logit()
}
model {
for (i in 1:N)
Y[i] ~ bernoulli(p[i]);
}"
#data
yData<-list(     )
## 1.実際に乱数を生成し、その母数を推定する
#pythonで既知の母数を持つ正規乱数を生成し、その結果のみを用いて母数を推定してみよう。<br>
#stanがベイズ推論した母数は、真の母数と一致するだろうか？
library(rstan)
y=rnorm(100,30,9) #期待値30、標準偏差9の正規分布に従う乱数を100個生成する
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real mu;
real<lower=0> sigma;
}
model {
for (i in 1:N)
Y[i] ~ normal(mu,sigma);
}
"
y=rnorm(100,30,9) #期待値30、標準偏差9の正規分布に従う乱数を100個生成する
y
hist(y)
yData<-list(N=length(y),Y=y)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
traceplot(fit)
stan_hist(fit)
help("stan_hist")
stan_dens(fit,separate_chains = True)
stan_dens(fit,separate_chains = TRUE)
fit<-stan(
model_code = model,
data=yData,
iter=50,
warmup=0,
thin=1,
chains=3)
traceplot(fit)
fit<-stan(
model_code = model,
data=yData,
iter=500,
warmup=0,
thin=1,
chains=3)
traceplot(fit)
traceplot(fit)
fit<-stan(
model_code = model,
data=yData,
iter=500,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
fit<-stan(
model_code = model,
data=yData,
iter=5000,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_dens(fit,separate_chains = TRUE)
stan_hist(fit)
hoge<-rpois(100,10)
hist(hoge)
hoge<-rpois(1000,10)
hist(hoge)
fuga<-rgamma(100,1,rate=3)
hist(fuga)
fit
mean(y)
y=rexp(100,rate = 5)
hist(y)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real <lower=0>lambda ;
}
model {
for (i in 1:N)
Y[i] ~ exponential(lambda);
}"
yData<-list(N=length(y),Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
## 2.線形回帰をベイズ推論してみよう
#YはXの1次関数でモデル化できるようなデータがあるとする。<br>
#このとき、y=ax+b+εと書ける。a,b,V[ε]を推定しよう。（εは期待値0の正規分布）
library(rstan)
x=runif(100,0,30)
x
y=10*x+23+rnorm(100,0,15)
y
plot(x,y)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] X;
vector[N] Y;
}
parameters {
real a;
real b;
real<lower=0> sigma;
}
model {
for (i in 1:N)
Y[i] ~ normal(a*X[i]+b,sigma);
}"
yData<-list(N=length(y),X=x,Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
fit
traceplot(fit)
#Rの機能で線形回帰（これは古典統計的なの最小二乗法）
reg<-lm(formula = y~x)
summary(reg)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] X;
vector[N] Y;
}
parameters {
real a;
real b;
real<lower=0> sigma;
}
model {
//for (i in 1:N)
//Y[i] ~ normal(a*X[i]+b,sigma);
Y~normal(a*X+b,sigma);
}"
yData<-list(N=length(y),X=x,Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
library(rstan)
#tree dataを読み込む。
df<-trees
pairs(df)
df
pairs(df)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] H;
vector[N] G;
vector[N] V;
}
parameters {
real c;
real<lower=0> sigma;
}
model {
for (i in 1:N)
V[i] ~ normal(c*H[i]*G[i]*G[i],sigma*H[i]);
}"
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=2000,
warmup=1000,
thin=1,
chains=3)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] H;
vector[N] G;
vector[N] V;
}
parameters {
real c;
real<lower=0> sigma;
}
model {
for (i in 1:N)
V[i] ~ normal(c*H[i]*G[i]*G[i],sigma);
}"
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=2000,
warmup=1000,
thin=1,
chains=3)
traceplot(fit) #定常状態になっているかしっかりチェックせよ
stan_hist(fit)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] H;
vector[N] G;
vector[N] V;
}
parameters {
real c;
real<lower=0> sigma;
}
model {
for (i in 1:N)
V[i] ~ normal(c*H[i]*G[i]*G[i],sigma);
}"
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=2000,
warmup=1000,
thin=1,
chains=3)
library(rstan)
#tree dataを読み込む。
df<-trees
df
pairs(df)
#data
yData<-list(N=length(df$Volume),H=df$Height,G=df$Girth,V=df$Volume)
df
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] H;
vector[N] G;
vector[N] V;
}
parameters {
real c;
real<lower=0> sigma;
}
model {
for (i in 1:N)
V[i] ~ normal(c*H[i]*G[i]*G[i],sigma);
}"
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=2000,
warmup=1000,
thin=1,
chains=3)
traceplot(fit) #定常状態になっているかしっかりチェックせよ
stan_hist(fit)
fit
traceplot(fit) #定常状態になっているかしっかりチェックせよ
fit<-stan(
model_code = model,
data=yData,
iter=2000,
warmup=100,
thin=1,
chains=3)
traceplot(fit) #定常状態になっているかしっかりチェックせよ
stan_hist(fit)
traceplot(fit) #定常状態になっているかしっかりチェックせよ
fit<-stan(
model_code = model,
data=yData,
iter=2000,
warmup=1000,
thin=1,
chains=3)
traceplot(fit) #定常状態になっているかしっかりチェックせよ
stan_hist(fit)
fit
#まずはデータ作成
library(rstan)
x1=runif(100,0,30)
x2=runif(100,30,40)
y=10*x1-23*x2-15+rnorm(100,0,15)
#まずはデータ作成
library(rstan)
x1=runif(100,0,30)
x2=runif(100,30,40)
y=10*x1-23*x2-15+rnorm(100,0,15)
pairs(data.frame(x1,x2,y))
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるが、可読性を高めるためちゃんとインデントしよう。
model <- "
data {
int N;
real X1[N];
vector[N] X2;
vector[N] Y;
}
parameters {
real a1;
real a2;
real b;
real<lower=0> sigma;
}
transformed parameters{
real mu[N]; //長さNの実数ベクトルを作る
for (i in 1:N)
mu[i] = a1*X1[i]+a2*X2[i]+b; //for文で、各データポイントに対して期待値muを作成
}
model {
for (i in 1:N)
Y[i] ~ normal(mu[i],sigma);
}"
yData<-list(N=length(y),X1=x1,X2=x2,Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
fit
#会社効果はそれぞれND(0,10^2)に従う。
kaisha_kouka<-rnorm(4,0,10)
kaisha_kouka
#会社効果はそれぞれND(0,10^2)に従う。
kaisha_kouka<-rnorm(4,0,10)
kaisha_kouka
#会社効果はそれぞれND(0,10^2)に従う。
kaisha_kouka<-rnorm(4,0,10)
kaisha_kouka
kaisha<-"A"*25
kaisha<-rep("A")
kaisha
kaisha<-rep("A",20)
kaisha
#社員の退職金は、勤続年数の1次関数に個人固有の値を足したものであるが、1次関数の切片と係数は会社固有の値である。
kinzoku<-runinf(100,5,20)
#社員の退職金は、勤続年数の1次関数に個人固有の値を足したものであるが、1次関数の切片と係数は会社固有の値である。
kinzoku<-runif(100,5,20)
kaisha<-rep("A",25)+rep("B",25)+rep("C",25)+rep("D",25)
kaisha<-c(rep("A",25),rep("B",25),rep("C",25),rep("D",25))
kaisha
#会社固有の回帰係数はND(10,1^2)に、会社固有の切片はND(20,5^2)に従う。
kaisha_keisu<-rnorm(4,10,1)
kaisha_seppen<-rnorm(4,20,5)
x<-data.frame(kinzoku,kaisha)
x
A_shain<-kinzoku[kaisha=="a"]
A_shain
A_shain<-kinzoku[kaisha=="A"]
A_shain
A_shain<-kinzoku[kaisha=="A"]*kaisha_keisu[1]+kaisha_seppen[1]+rnorm(25,2)
A_shain
plot(kinzoku[kaisha=="A"],A_shain)
A_shain<-kinzoku[kaisha=="A"]*kaisha_keisu[1]+kaisha_seppen[1]+rnorm(25,10)
plot(kinzoku[kaisha=="A"],A_shain)
A_shain<-kinzoku[kaisha=="A"]*kaisha_keisu[1]+kaisha_seppen[1]+rnorm(25,30)
plot(kinzoku[kaisha=="A"],A_shain)
A_shain<-kinzoku[kaisha=="A"]*kaisha_keisu[1]+kaisha_seppen[1]+rnorm(25,0,30)
plot(kinzoku[kaisha=="A"],A_shain)
A_shain<-kinzoku[kaisha=="A"]*kaisha_keisu[1]+kaisha_seppen[1]+rnorm(25,0,2)
plot(kinzoku[kaisha=="A"],A_shain)
A_shain<-kinzoku[kaisha=="A"]*kaisha_keisu[1]+kaisha_seppen[1]+rnorm(25,0,4)
plot(kinzoku[kaisha=="A"],A_shain)
B_shain<-kinzoku[kaisha=="B"]*kaisha_keisu[2]+kaisha_seppen[2]+rnorm(25,0,4)
C_shain<-kinzoku[kaisha=="C"]*kaisha_keisu[3]+kaisha_seppen[3]+rnorm(25,0,4)
D_shain<-kinzoku[kaisha=="D"]*kaisha_keisu[4]+kaisha_seppen[4]+rnorm(25,0,4)
taishokukin<-c(A_shain,B_shain,C_shain,D_shain)
pairs(kinzoku,taishokukin)
plot(kinzoku,taishokukin)
df<-data.frame(kinzoku,kaisha,taishokukin)
df
library(rstan)
library("rstan")
setwd("~/sugakubunka-statistics/bayse")
library(rstan)
