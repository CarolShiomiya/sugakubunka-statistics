test <- tibble(X1, X2, y)
# 訓練データの可視化
ggpairs(train)
train
# モデル構築
dtr_under <- decision_tree(mode = "regression", tree_depth = 1)
fit_under <- d_under %>% set_engine("rpart") %>% fit(y ~ ., data = train)
# モデル構築
d_under <- decision_tree(mode = "regression", tree_depth = 1)
fit_under <- d_under %>% set_engine("rpart") %>% fit(y ~ ., data = train)
# モデル評価
pred_under_train <- predict(fit_under, train) %>% bind_cols(train)
metrics_under_train <- pred_under_train %>% metrics(truth = y, estimate = .pred)
metrics_under_train
pred_under_test <- predict(fit_under, test) %>% bind_cols(test)
metrics_under_test <- pred_under_test %>% metrics(truth = y, estimate = .pred)
metrics_under_test
fit_under$fit$variable.importance
# モデル構築
dtr_middle <- decision_tree(mode = "regression", tree_depth = 3)
fit_middle <- dtr_middle %>% set_engine("rpart") %>% fit(y ~ ., data = train)
# モデル評価
pred_middle_train <- predict(fit_middle, train) %>% bind_cols(train)
metrics_middle_train <- pred_middle_train %>% metrics(truth = y, estimate = .pred)
metrics_middle_train
pred_middle_test <- predict(fit_middle, test) %>% bind_cols(test)
metrics_middle_test <- pred_middle_test %>% metrics(truth = y, estimate = .pred)
metrics_middle_test
fit_middle$fit$variable.importance
# モデル構築
dtr_over <- decision_tree(mode = "regression", tree_depth = 4)
fit_over <- dtr_over %>% set_engine("rpart") %>% fit(y ~ ., data = train)
# モデル評価
pred_over_train <- predict(fit_over, train) %>% bind_cols(train)
metrics_over_train <- pred_over_train %>% metrics(truth = y, estimate = .pred)
metrics_over_train
pred_over_test <- predict(fit_over, test) %>% bind_cols(test)
metrics_over_test <- pred_over_test %>% metrics(truth = y, estimate = .pred)
metrics_over_test
fit_over$fit$variable.importance
# モデル構築
dtr_under <- decision_tree(mode = "regression", tree_depth = 1)
fit_under <- dtr_under %>% set_engine("rpart") %>% fit(y ~ ., data = train)
# モデル評価
pred_under_train <- predict(fit_under, train) %>% bind_cols(train)
metrics_under_train <- pred_under_train %>% metrics(truth = y, estimate = .pred)
metrics_under_train
fit_under$fit$variable.importance
# モデル評価
pred_under_train <- predict(fit_under, train) %>% bind_cols(train)
metrics_under_train <- pred_under_train %>% metrics(truth = y, estimate = .pred)
metrics_under_train
# モデル構築
dtr_over <- decision_tree(mode = "regression", tree_depth = 4)
fit_over <- dtr_over %>% set_engine("rpart") %>% fit(y ~ ., data = train)
# モデル評価
pred_over_train <- predict(fit_over, train) %>% bind_cols(train)
metrics_over_train <- pred_over_train %>% metrics(truth = y, estimate = .pred)
metrics_over_train
pred_over_test <- predict(fit_over, test) %>% bind_cols(test)
metrics_over_test <- pred_over_test %>% metrics(truth = y, estimate = .pred)
metrics_over_test
fit_over$fit$variable.importance
rnorm(3)
rnorm(3,-3,4)
c(rnorm(7,-3,4),rnorm(8,2,1))
x2<-c(rnorm(7,4,1),rnorm(8,-1,3))
y<-c(1,1,1,1,1,1,1,0,0,0,0,0,0,0,0)
data.frame(x1,x2,y)
x1<-c(rnorm(7,-3,4),rnorm(8,2,1))
x2<-c(rnorm(7,4,1),rnorm(8,-1,3))
y<-c(1,1,1,1,1,1,1,0,0,0,0,0,0,0,0)
data.frame(x1,x2,y)
y<-c(1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1)
data.frame(x1,x2,y)
w<-seq(1, 1, length = 15)
w
w<-seq(1, 1, length = 15)*1/15
w
data.frame(x1,x2,y,w)
Sys.setenv(MAKEFLAGS="-j4")
install.packages("rstan",repos="https://cloud.r-project.org/",dependencies = TRUE)
library("rstan")
library(rstan)
install.packages("rstan",repos="https://cloud.r-project.org/",dependencies = TRUE)
pkgbuild::has_build_tools(debug = TRUE)
install.packages("rstan",repos="https://cloud.r-project.org/",dependencies = TRUE)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan",repos="https://cloud.r-project.org/",dependencies = TRUE)
install.packages("rstan",repos="https://cloud.r-project.org/",dependencies = TRUE)
install.packages("openssl",repos="https://cloud.r-project.org/",dependencies = TRUE)
library(openssl)
install.packages("openssl",repos="https://cloud.r-project.org/",dependencies = TRUE)
library(openssl)
install.packages("openssl",repos="https://cloud.r-project.org/",dependencies = TRUE)
install.packages("openssl")
install.packages("libssl-dev")
install.packages("openssl")
install.packages("openssl",repos="https://cloud.r-project.org/",dependencies = TRUE)
library(openssl)
library(rstan)
install.packages("rstan",repos="https://cloud.r-project.org/",dependencies = TRUE)
install.packages("shinystan",repos="https://cloud.r-project.org/",dependencies = TRUE)
runif(1000,0,1)
r<-runif(1000,0,1)
hist(r)
r<-runif(1000,0,1)
tenki<-1
if (tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1
}
elif(r<0.9){
tenki2<-2
}
else{
tenki2<-3
}
}
tenki<-1
if (tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1
}elif(r<0.9){
tenki2<-2
}else{
tenki2<-3
}
}
tenki<-1
if (tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){tenki2<-1}elif(r<0.9){tenki2<-2}else{tenki2<-3}
}
if(3==3){
print(3)
}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){tenki2<-1
}elif(r<0.9){
tenki2<-2
}else{
tenki2<-3}
}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1
}elif(r<0.9){
tenki2<-2
}else{
tenki2<-3}
}
if(3==3){
print(3)
}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1
}elif(r<0.9){
tenki2<-2
}else{
tenki2<-3
}
}
tenki<-1
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1
}elif(r<0.9){
tenki2<-2
}else{
tenki2<-3
}
}
if(tenki==1){
r<-rnorm(1,0,1)
}
if(tenki==1){
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1
}
if(r<0.9 and r>0.7){
tenki2<-2}
if(r>0.9){
tenki2<-3
}
}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1}
if(r<0.9 and r>0.7){
tenki2<-2}
if(r>0.9){
tenki2<-3
}
}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1}
if(r<0.9 and r>0.7){
tenki2<-2}
if(r>0.9){
tenki2<-3}
}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){
tenki2<-1}
if(r<0.9 and r>0.7){
tenki2<-2}
if(r>0.9){
tenki2<-3}}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){tenki2<-1}if(r<0.9 and r>0.7){tenki2<-2}if(r>0.9){tenki2<-3}}
if(tenki==1){
r<-rnorm(1,0,1)
if(r<0.7){tenki2<-1} if(r<0.9 and r>0.7){tenki2<-2} if(r>0.9){tenki2<-3}}
localLevelModel_1<-"
data{
int n;
vector[n] Nile;
}
parameters{
real mu;
real<lower=0> sigmaV;
}
model{
for(i in 1:n){
Nile[i]~normal(mu,sqrt(sigmaV));
}
}
"
Nile
NileData<-list(Nile=as.numeric(Nile),n=length(Nile))
NileData
set.seed(1)
Nilemodel1<-stan(
model_code = localLevelModel_1,
data=NileData,
iter=1100,
warmup=100,
thin=1,
chains=3)
Nilemodel1
library(rstan)
localLevelModel_1<-"
data{
int n;
vector[n] Nile;
}
parameters{
real mu;
real<lower=0> sigmaV;
}
model{
for(i in 1:n){
Nile[i]~normal(mu,sqrt(sigmaV));
}
}
"
Nile
NileData<-list(Nile=as.numeric(Nile),n=length(Nile))
NileData
set.seed(1)
Nilemodel1<-stan(
model_code = localLevelModel_1,
data=NileData,
iter=1100,
warmup=100,
thin=1,
chains=3)
Nilemodel1
traceplot(Nilemodel1)
stan_hist(Nilemodel1)
y=rnorm(100,30,9) #期待値30、標準偏差9の正規分布に従う乱数を100個生成する
y
sd(y)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] y;
}
parameters {
real mu;
real<lower=0> sigma;
}
model {
for (i in 1:N)
y[i] ~ normal(mu,sigma);
}
"
y=rnorm(100,30,9) #期待値30、標準偏差9の正規分布に従う乱数を100個生成する
y
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real mu;
real<lower=0> sigma;
}
model {
for (i in 1:N)
Y[i] ~ normal(mu,sigma);
}
"
yData<-list(N=length(y),Y=y)
fit<-stan(
model_code = localLevelModel_1,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
library(rstan)
fit<-stan(
model_code = localLevelModel_1,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
fit
## 1.実際に乱数を生成し、その母数を推定する
#pythonで既知の母数を持つ正規乱数を生成し、その結果のみを用いて母数を推定してみよう。<br>
#stanがベイズ推論した母数は、真の母数と一致するだろうか？
library(rstan)
y=rnorm(100,30,9) #期待値30、標準偏差9の正規分布に従う乱数を100個生成する
y
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real mu;
real<lower=0> sigma;
}
model {
for (i in 1:N)
Y[i] ~ normal(mu,sigma);
}
"
plot(fit)
stan_plot(fit)
traceplot(fit)
Y<-rnorm(100,0,1)
Y
stan_hist(fit)
getwd()
setwd("~/sugakubunka-statistics/bayse")
## 1.実際に乱数を生成し、その母数を推定する
#pythonで既知の母数を持つ正規乱数を生成し、その結果のみを用いて母数を推定してみよう。<br>
#stanがベイズ推論した母数は、真の母数と一致するだろうか？
library(rstan)
x=runif(100,0,30)
x
x=runif(100,0,30)
x
y=10*x+23+rnorm(100,0,4)
y
plot(x,y)
y=10*x+23+rnorm(100,0,15)
y
plot(x,y)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] X;
vector[N] Y;
}
parameters {
real a;
real b;
real<lower=0> sigma;
}
model {
for (i in 1:N)
Y[i] ~ normal(a*X[i]+b,sigma);
}
"
yData<-list(N=length(y),X=x,Y=y)
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
fit
lm(formula = y~x)
#
reg<-lm(formula = y~x)
reg
summary(reg)
trees
pairs(trees)
## 2.線形回帰をベイズ推論してみよう(演習)
#tree dataを読み込む。
df<-trees
pairs(df)
df
Y=rexp(100,rate = 5)
Y
y=rexp(100,rate = 5)
y
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real lambda<lower=0>;
}
model {
for (i in 1:N)
Y[i] ~ exponential(lambda);
}"
yData<-list(N=length(y),Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real lambda <lower=0>;
}
model {
for (i in 1:N)
Y[i] ~ exponential(lambda);
}"
yData<-list(N=length(y),Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
# Stanコード。別ファイル（.stan）にdata{から書いてもよし。
#インデントを気にしない言語ではあるがちゃんとインデントしよう。
model <- "
data {
int N;
vector[N] Y;
}
parameters {
real <lower=0>lambda ;
}
model {
for (i in 1:N)
Y[i] ~ exponential(lambda);
}"
yData<-list(N=length(y),Y=y)
#yData<-list(N=length(y),X=x,Y=y,new_N=5,new_X=c(5,10,15,20,25))
library(rstan)
fit<-stan(
model_code = model,
data=yData,
iter=1100,
warmup=100,
thin=1,
chains=3)
traceplot(fit)
stan_hist(fit)
fit
